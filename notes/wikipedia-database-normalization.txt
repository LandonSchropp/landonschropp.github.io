1:"$Sreact.fragment"
2:I[9928,[],""]
3:I[1054,[],""]
4:I[383,["458","static/chunks/458-d936935f6de7c2f9.js","763","static/chunks/app/notes/layout-b12473e1ad399ce3.js"],"MainNavigation"]
5:"$Sreact.suspense"
7:I[9209,[],"OutletBoundary"]
9:I[9209,[],"MetadataBoundary"]
b:I[9209,[],"ViewportBoundary"]
d:I[4455,[],""]
:HL["/_next/static/css/d40ab0564747cb66.css","style"]
:HL["/_next/static/css/5aabacac4a7bcbc4.css","style"]
:HL["/_next/static/css/b7bdc2d4d4aa6554.css","style"]
:HL["/_next/static/css/9cad1c3a621a47c7.css","style"]
:HL["/_next/static/css/34f92507e61baad2.css","style"]
0:{"P":null,"b":"rJvg0KUuQj6HUJizNv5yz","p":"","c":["","notes","wikipedia-database-normalization"],"i":false,"f":[[["",{"children":["notes",{"children":[["slug","wikipedia-database-normalization","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/d40ab0564747cb66.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en-us","className":"h-full text-[19px] md:text-[21px] lg:text-[22px]","children":[["$","head",null,{"children":[["$","link",null,{"rel":"preconnect","href":"https://fonts.googleapis.com"}],["$","link",null,{"rel":"preconnect","href":"https://fonts.gstatic.com","crossOrigin":"anonymous"}],["$","link",null,{"href":"https://fonts.googleapis.com/css2?family=Gentium+Book+Plus:ital,wght@0,400;0,700;1,400;1,700&family=Open+Sans:ital,wght@0,400;0,700;0,800;1,400;1,700;1,800&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap","rel":"stylesheet"}],["$","link",null,{"rel":"shortcut icon","type":"image/png","href":"/_next/static/media/flannel.5168cfc2.png"}]]}],["$","body",null,{"className":"flex h-full flex-col bg-theme-background font-serif font-normal text-theme-text *:flex-[0_0_auto]","children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],null],"forbidden":"$undefined","unauthorized":"$undefined"}]}]]}]]}],{"children":["notes",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/5aabacac4a7bcbc4.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/b7bdc2d4d4aa6554.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","2",{"rel":"stylesheet","href":"/_next/static/css/9cad1c3a621a47c7.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","3",{"rel":"stylesheet","href":"/_next/static/css/34f92507e61baad2.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],[["$","$L4",null,{}],["$","main",null,{"className":"mx-auto w-[70ch] max-w-full px-2 md:px-4","children":["$","$5",null,{"children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","notes","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]]}],{"children":[["slug","wikipedia-database-normalization","d"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","notes","children","$0:f:0:1:2:children:2:children:0","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L6",null,["$","$L7",null,{"children":"$L8"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","mUvu9DFbKSW2RAl2hhpF3",{"children":[["$","$L9",null,{"children":"$La"}],["$","$Lb",null,{"children":"$Lc"}],null]}]]}],false]],"m":"$undefined","G":["$d","$undefined"],"s":false,"S":true}
c:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
e:I[3176,["794","static/chunks/794-3921d1a8df069f9c.js","740","static/chunks/app/notes/%5Bslug%5D/page-d0c2f0b3305d5fd0.js"],"Note"]
f:T30d4,Database normalization is the process of restructuring a database to follow a series of _normal forms._ These are typically designated first normal form (1NF), second normal form (2NF), third normal form (3NF), etc. The goal is to reduce data redundancy and increase data integrity. This concept was initially introduced by Edgar F. Codd in 1970.

One key idea behind normalization is that **each normal form must meet the criteria for the form before it**. For example, before normalizing a relation to 3NF, it must first be in 2NF.

## Why Normalize?

According to Codd, there are many benefits of normalizing data beyond 1NF:

- A normalized database does not have undesirable insertion, update and deletion anomalies.
- When the database structure is extended, it’s much less likely that a normalized database will need to change its existing structure.
- A normalized database is more informative to its users.
- The design will remain adaptable and won’t become inefficient or slow due to changes in how the data is used or which queries become more common.

When a database is not normalized, the following types of anomalies can occur:

- **Insertion anomaly:** It’s possible that a record can’t be inserted into a relation at all. This can occur when some of the required data is not yet available.
- **Update anomaly:** If the same information is expressed in multiple rows, and one of the rows is updated, then a logical inconsistency between rows can occur.
- **Deletion anomaly:** It’s possible that deleting certain records necessitates deleting other data from completely different facts.

The [Objectives](https://en.wikipedia.org/wiki/Database_normalization#Objectives) section of the article gives good examples of each of these anomalies.

## Definitions

Before we can dive into normalization, there are a bunch of terms that are helpful to define.

- **Attribute:** A database column.
- **Relation:** A database table.

- **Superkey:** _Any_ set of attributes that uniquely identifies a row in a relation. The set of all attributes is known as the _trivial superkey_.
- **Candidate key (or just key):** A minimal set of attributes that have a unique combination of values in each row. Removing any attribute from this set can produce duplicates in the database.
  A candidate key is a _superkey_ that can’t be reduced by removing an attribute.
- **Primary key:** A specific choice of a _candidate key_. This is purely a DBMS concept and not applicable to relational theory. However, from a _practical_ standpoint, a _candidate key_ can be thought of as the primary key of a relation (except when a relation has multiple candidate keys, which is very rare).
- **Alternate key (or secondary key):** A _candidate key_ that is not the _primary key_.
- **Prime attributes:** The set of columns contained in _any_ of the _candidate keys_.
- **Non-prime attributes:** The columns that do not occur in _any_ _candidate keys_.
- **Functional dependency:** A constraint between two attributes in a database.
  > *X* → *Y* means that the values of *Y* are determined by the values of *X*. Two tuples sharing the same values of *X* will necessarily have the same values of *Y*.
- **Partial dependency:** A _non-prime attribute_ that is _functionally dependent_ on any _proper subset_ of any _candidate key_ of the relation.
  This is discussed in more detail in the Second Normal Form section below.
- **Transitive dependency:** A functional dependency where X → Z indirectly through another attribute Y (X → Y, Y → Z and Y ↛ X).
  Transitive dependencies are named from the transitive property in mathematics (if A = B and B = C, then A = C) or logical proofs (if A implies B and B implies C, then A implies C).

## First Normal Form (1NF)

At the core of 1NF is the idea that values should be _atomic_. According to Codd, this means that _the value cannot be broken down into smaller pieces_.

### Disagreement

Surprisingly, this definition is very hazy, and there’s some disagreement on what atomicity means. [This Stack Overflow answer](https://stackoverflow.com/a/24038895/262125) gives a wonderful overview of some of the history and disagreements with the definition.

In Codd’s original paper, he intended columns not to contain sub-relations (paraphrased). Since this, it’s been more loosely interpreted as not allowing complex sub-types. For example, a `jsonb` data type would be considered a violation of 1NF, as would a JSON string.

Another computer scientist, Chris Date, has proposed an [alternate definition](https://en.wikipedia.org/wiki/First_normal_form#1NF_tables_as_representations_of_relations). However, it’s been criticized for disallowing `null` values.

[This Stack Exchange answer](https://dba.stackexchange.com/a/2362) gives an interesting definition that might be more practically useful.

> "Atomic" means if a value has component parts, the DBMS either ignores the existence of those parts, or it provides functions to manipulate them.

This allows for data types such as a date, which can be further decomposed into a year, month and day. It also allows for more complex JSON types.

### Summary

After sampling from several sources (including Chris Date’s definition), a good set of rules 1NF might be:

- **No ordering:** The insertion order of rows or columns does not matter.
- **No duplication:** No rows are duplicated. This is achieved by using a primary key.
- **Same type:** Every value in a column should have the same data type.
- **Atomic:** The values in columns cannot be decomposed to sub-values unless the DBMS provides manipulation functions.
  Generally, this means sticking with data types provided by the DBMS and now embedding pseudo-types within other types, such as JSON embedded in strings.

## Second Normal Form (2NF)

In addition to being in 1NF, a relation in 2NF must not have any partial dependencies. A _partial dependency_ is where a non-prime attribute is functionally dependent on a _subset_ of the candidate key (as opposed to the _entire_ candidate key).

This can be broken down as follows:

- If a relation only has a single attribute in its candidate key, it will never have any partial dependencies, so it’s always in 2NF.
- If a relation has a multi-attribute candidate key, then every non-prime attribute must depend on _all_ candidate key attributes.

### Example

Wikipedia gives this great example.

| Manufacturer | Model       | Manufacturer Country |
| ------------ | ----------- | -------------------- |
| Forte        | X-Prime     | Italy                |
| Forte        | Ultraclean  | Italy                |
| Dent-o-Fresh | EZbrush     | USA                  |
| Brushmaster  | SuperBrush  | USA                  |
| Kobayashi    | ST-60       | Japan                |
| Hoch         | Toothmaster | Germany              |
| Hoch         | X-Prime     | Germany              |

In this example, the candidate key is {Manufacturer, Model}. Manufacturer Country is a non-prime attribute that is functionally dependent on Manufacturer. Since this is only part of the candidate key, Manufacturer has a partial dependency.

### Normalization

To normalize a relation to conform to 2NF, remove the partially dependent attributes and place them in a separate relation where _all_ candidate key attributes determine the value of the non-prime attributes.

## Third Normal Form (3NF)

A relation is in 3NF if:

- The relation is in 2NF.
- No non-prime attribute can be transitively dependent on a candidate key.

In other words, a relation would _not_ be in third normal form if it contained a non-prime attribute that was transitively dependent on a candidate key through another attribute.

### Example

This definition is a bit difficult to understand formally, but much easier to understand via an example. Wikipedia gives the following Tournament Winners table.

| Tournament           | Year | Winner         | Date of Birth      |
| -------------------- | ---- | -------------- | ------------------ |
| Indiana Invitational | 1998 | Al Fredrickson | July 21, 1975      |
| Cleveland Open       | 1999 | Bob Albertson  | September 28, 1968 |
| Des Moines Masters   | 1999 | Al Fredrickson | July 21, 1975      |
| Indiana Invitational | 1999 | Chip Masterson | March 14, 1977     |

In this example, the Date of Birth is dependent on the Winner, and the Winner is dependent on the Candidate Key {Tournament, Year}, so Date of Birth is transitively dependent on {Tournament, Year}.

This could easily lead to an update anomaly where a Date of Birth is different in separate records because it’s possible to have multiple Date of Birth values.

### Normalizing

Like 2NF, the approach to normalizing 3NF is to split the attributes with transitive dependencies into a separate relation.

## Boyce-Codd Normal Form (BCNF)

Raymond Boyce and Edger Codd developed Boyce-Codd normal form in 1971 to address certain issues with 3NF. It can be thought of as a slightly stricter version of 3NF that removes the edge cases.

Boyce and Codd’s development of this normal form was actually predated by Ian Heath in 1971.

> Since that definition predated Boyce and Codd's own definition by some three years, it seems to me that BCNF ought by rights to be called *Heath* normal form. But it isn't.

### Rewriting Third Normal Form

Before defining BCNF, it would be helpful to rewrite 3NF using this equivilent definition created by Carlo Zaniolo in 1981.

> A table is in 3NF if and only if for each of its functional dependencies X → Y, at least one of the following conditions holds:
>
> - X contains Y (that is, Y is a subset of X, meaning X → Y is a trivial functional dependency)
> - X is a superkey
> - Every element of Y − X, the set difference between Y and X, is a prime attribute (i.e., each attribute in Y − X is contained in some candidate key).

In other words, a relation is in 3NF if, for _every_ functional dependency X → Y, one of the following is true:

- Y is a subset of X
- X is a superkey
- Each element contained in Y - X is a prime attribute.

### Definition

With that ironed out, we can define BCNF and simply lacking the last option for functional dependencies:

> A relational schema R is in Boyce–Codd normal form if and only if for every one of its dependencies X → Y, at least one of the following conditions hold:
>
> - X → Y is a trivial functional dependency (Y ⊆ X)
> - X is a superkey for schema R

In other words, a relation is in 3NF if, for _every_ functional dependency X → Y, one of the following is true:

- Y is a subset of X
- X is a superkey

### Example

Wikipedia gives this tricky Tennis Court Bookings relation as an example.

| Court | Start time | End time | Rate Type |
| ----- | ---------- | -------- | --------- |
| 1     | 09:30      | 10:30    | SAVER     |
| 1     | 11:00      | 12:00    | SAVER     |
| 1     | 14:00      | 15:30    | STANDARD  |
| 2     | 10:00      | 11:30    | PREMIUM-B |
| 2     | 11:30      | 13:30    | PREMIUM-B |
| 2     | 15:00      | 16:30    | PREMIUM-A |

- Each row represents a booking at a tennis club. The tennis club has one hard court (Court 1) and one grass court (Court 2).
- Each booking has a rate type associated with it. The court and the booker’s membership status determine the Rate Type:
  - Court 1 bookings made by members have SAVER.
  - Court 1 bookings made by non-members have STANDARD.
  - Court 2 bookings made by members have PREMIUM-A.
  - Court 2 bookings made by non-members have Premium-B.

Combining these attributes results in four possible candidate keys:

- S₁ = {Court, Start time}
- S₂ = {Court, End time}
- S₃ = {Rate type, Start time}
- S₄ = {Rate type, End time}

Intuitively, this makes sense. Court bookings cannot overlap, and the Rate Type is derived partially from the Court.

The tricky thing about these examples is _none_ of the attributes in the Court Bookings table are non-prime because all attributes are contained in at least one of the candidate keys. Therefore, this table can never violate 3NF.

However, it violates BCNF because the functional dependency Rate Type → Court because Court is not a subset of Rate Type and Rate Type is not a superkey.

### Normalization

Like the other options, the key to normalizing to 3NF involves splitting the table. However, unlike 3NF, this is [not always possible](https://en.wikipedia.org/wiki/Boyce%E2%80%93Codd_normal_form#Achievability_of_BCNF). 😮6:["$","$Le",null,{"note":{"title":"Database Normalization","slug":"wikipedia-database-normalization","date":"2024-04-01","published":true,"markdown":"$f","filePath":"/Users/landon/Notes/Resources/Notes/Development/Database Normalization (Wikipedia).md","authors":[],"category":"Development","media":"Article","url":"https://en.wikipedia.org/wiki/Database_normalization","source":"Wikipedia"}}]
a:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"Landon Schropp – Database Normalization"}],["$","meta","2",{"name":"description","content":"Landon Schropp's notes about Database Normalization"}],["$","meta","3",{"name":"author","content":"Landon Schropp"}]]
8:null
